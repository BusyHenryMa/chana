/*
 * Definition of JPQL grammar.
 * 
 * @author Caoyuan Deng
 */
module chana.jpql.rats.JPQLGrammar;

import Character;
import Identifier;
import Keyword;
import Literal;
import Separator;
import Spacing;
import State;

option withLocation;


// ----- public entrance
public generic JPQL = 
  SelectStatement
/ UpdateStatement
/ DeleteStatement
;

generic SelectStatement = 
  SelectClause FromClause WhereClause? GroupbyClause? HavingClause? OrderbyClause?
;

generic UpdateStatement =
  UpdateClause WhereClause?
;

generic DeleteStatement =
  DeleteClause WhereClause?
;

generic FromClause =
  FROM IdentVarDecl ( COMMA ( IdentVarDecl / CollectionMemberDecl) )*
;

generic IdentVarDecl =
  RangeVarDecl ( Join / FetchJoin )*
;

generic RangeVarDecl = 
  EntityName AS? IdentVar
;

generic Join = 
  JoinSpec JoinAssocPathExpr AS? IdentVar JoinCond?
;

generic FetchJoin = 
  JoinSpec FETCH JoinAssocPathExpr JoinCond?
;

generic JoinSpec = 
  JOIN
/ LEFT JOIN
/ LEFT OUTER JOIN
/ INNER JOIN
;

generic JoinCond = 
  ON CondExpr
;

generic JoinAssocPathExpr = 
  JoinCollectionValuedPathExpr
/ JoinSingleValuedPathExpr
/ TREAT LParen JoinCollectionValuedPathExpr AS Subtype RParen
/ TREAT LParen JoinSingleValuedPathExpr     AS Subtype RParen
;

generic JoinCollectionValuedPathExpr = 
  IdentVar DOT ( SingleValuedEmbeddableObjectField DOT )* CollectionValuedField
;

generic JoinSingleValuedPathExpr = 
  IdentVar DOT ( SingleValuedEmbeddableObjectField DOT )* SingleValuedObjectField
;

generic CollectionMemberDecl =
  IN LParen CollectionValuedPathExpr RParen AS? IdentVar
;

generic QualIdentVar = 
   ComposableQualIdentVar
 / ENTRY LParen IdentVar RParen
;

generic ComposableQualIdentVar = 
  KEY    LParen IdentVar RParen
/ VALUE  LParen IdentVar RParen
;

generic SingleValuedPathExpr = 
  QualIdentVar
/ TREAT LParen QualIdentVar RParen
/ StateFieldPathExpr
/ SingleValuedObjectPathExpr
;

generic GeneralIdentVar =
  IdentVar
/ ComposableQualIdentVar
;

generic GeneralSubpath = 
  SimpleSubpath
/ TreatedSubpath ( DOT SingleValuedObjectField )*
;

generic SimpleSubpath = 
  GeneralIdentVar ( DOT SingleValuedObjectField )*
; 

generic TreatedSubpath = 
  TREAT LParen GeneralSubpath AS Subtype RParen
; 

generic StateFieldPathExpr = 
  GeneralSubpath // DOT StateField
;

generic SingleValuedObjectPathExpr = 
  GeneralSubpath // DOT SingleValuedObjectField
;

generic CollectionValuedPathExpr = 
  GeneralSubpath // DOT CollectionValuedField
;

generic UpdateClause =
  UPDATE EntityName ( AS? IdentVar )? SET UpdateItem ( COMMA UpdateItem )*
;

generic UpdateItem =
  ( IdentVar DOT )? ( SingleValuedEmbeddableObjectField DOT )* ( StateField / SingleValuedObjectField ) EQ NewValue
;

generic NewValue =
  ScalarExpr
;

generic DeleteClause =
  DELETE FROM EntityName ( AS? IdentVar )?
;

generic SelectClause = 
  SELECT DISTINCT? SelectItem (COMMA SelectItem )* 
; 

generic SelectItem = 
  SelectExpr ( AS? ResultVar )?
;

generic SelectExpr = 
  AggregateExpr
/ OBJECT LParen IdentVar RParen
/ ConstructorExpr
/ SingleValuedPathExpr
/ ScalarExpr
;

generic ConstructorExpr =
  NEW ConstructorName LParen ConstructorItem ( COMMA ConstructorItem )* RParen
;

generic ConstructorItem =
  AggregateExpr
/ SingleValuedPathExpr
/ ScalarExpr
;

generic AggregateExpr = 
  ( AVG / MAX / MIN / SUM ) LParen DISTINCT? StateFieldPathExpr RParen
/ COUNT                     LParen DISTINCT? ( IdentVar 
                                             / StateFieldPathExpr 
                                             / SingleValuedObjectPathExpr 
                                             )
                            RParen
/ FuncInvocation
;


generic WhereClause =
  WHERE CondExpr 
;

generic GroupbyClause =
  GROUP BY GroupbyItem ( COMMA GroupbyItem )* 
;

generic GroupbyItem =
  SingleValuedPathExpr
/ IdentVar
;

generic HavingClause =
  HAVING CondExpr 
;

generic OrderbyClause =
  ORDER BY OrderbyItem ( COMMA OrderbyItem )*
;

generic OrderbyItem =
  ( StateFieldPathExpr / ResultVar ) ( ASC / DESC )?
;

generic Subquery =
  SimpleSelectClause SubqueryFromClause WhereClause? GroupbyClause? HavingClause?
;

generic SubqueryFromClause =
  FROM SubselectIdentVarDecl ( COMMA ( SubselectIdentVarDecl 
                                     / CollectionMemberDecl
                                     ) 
                             )*
;

generic SubselectIdentVarDecl = 
  IdentVarDecl 
/ DerivedPathExpr AS? IdentVar Join*
/ DerivedCollectionMemberDecl
;

generic DerivedPathExpr = 
  GeneralDerivedPath DOT SingleValuedObjectField
/ GeneralDerivedPath DOT CollectionValuedField
;

generic GeneralDerivedPath =
  SimpleDerivedPath
/ TreatedDerivedPath ( DOT SingleValuedObjectField )*
;

generic SimpleDerivedPath =
  SuperqueryIdentVar ( DOT SingleValuedObjectField )*
;

generic TreatedDerivedPath =
  TREAT LParen GeneralDerivedPath AS Subtype RParen
;

generic DerivedCollectionMemberDecl =
  IN SuperqueryIdentVar DOT ( SingleValuedObjectField DOT )* CollectionValuedField
;

generic SimpleSelectClause =
  SELECT DISTINCT? SimpleSelectExpr
;

generic SimpleSelectExpr = 
  AggregateExpr
/ SingleValuedPathExpr 
/ ScalarExpr
;

generic ScalarExpr = 
  StringExpr
/ EnumExpr
/ DatetimeExpr
/ BooleanExpr
/ CaseExpr
/ EntityTypeExpr
/ ArithExpr
;

generic CondExpr =
  CondTerm ( void:OR CondExpr )*
;

generic CondTerm =
  CondFactor ( void:AND CondFactor )*
;

generic CondFactor =
  NOT? CondPrimary
;

generic CondPrimary =
  SimpleCondExpr
/ LParen CondExpr RParen
;

generic SimpleCondExpr =
  ComparisonExpr
/ BetweenExpr
/ LikeExpr
/ InExpr
/ NullComparisonExpr
/ EmptyCollectionComparisonExpr
/ CollectionMemberExpr
/ ExistsExpr
;

generic BetweenExpr =
  ArithExpr NOT? BETWEEN ArithExpr AND ArithExpr
/ StringExpr     NOT? BETWEEN StringExpr     AND StringExpr
/ DatetimeExpr   NOT? BETWEEN DatetimeExpr   AND DatetimeExpr
;

generic InExpr =
  ( StateFieldPathExpr / TypeDiscriminator ) NOT? IN ( LParen InItem ( COMMA InItem )* RParen 
                                                     / LParen Subquery RParen
                                                     / CollectionValuedInputParam
                                                     )
;

generic InItem =
  Literal
/ SingleValuedInputParam
;

generic LikeExpr =
  StringExpr NOT? LIKE PatternValue ( ESCAPE EscapeChar )?
;

generic NullComparisonExpr =
  ( SingleValuedPathExpr / InputParam) IS NOT? NULL 
;

generic EmptyCollectionComparisonExpr =
  CollectionValuedPathExpr IS NOT? EMPTY 
;

generic CollectionMemberExpr =
  EntityOrValueExpr NOT? MEMBER OF? CollectionValuedPathExpr
;

generic EntityOrValueExpr =
  SingleValuedObjectPathExpr
/ StateFieldPathExpr
/ SimpleEntityOrValueExpr
;

generic SimpleEntityOrValueExpr =
  IdentVar
/ InputParam
/ Literal
;

generic ExistsExpr =
  NOT? EXISTS LParen Subquery RParen 
;

generic AllOrAnyExpr =
  ( ALL / ANY / SOME ) LParen Subquery RParen
;

generic ComparisonExpr =
  StringExpr     ComparisonOp ( StringExpr   / AllOrAnyExpr )
/ BooleanExpr    ( EQ / NE )  ( BooleanExpr  / AllOrAnyExpr )
/ EnumExpr       ( EQ / NE )  ( EnumExpr     / AllOrAnyExpr )
/ DatetimeExpr   ComparisonOp ( DatetimeExpr / AllOrAnyExpr )
/ EntityExpr     ( EQ / NE )  ( EntityExpr   / AllOrAnyExpr )
/ EntityTypeExpr ( EQ / NE )  EntityTypeExpr
/ ArithExpr      ComparisonOp AllOrAnyExpr
/ ArithExpr      ComparisonOp ArithExpr
;

generic ComparisonOp =
  EQ / GE / GT / NE / LT / LE
;

generic ArithExpr = 
  ArithTerm ( void:( PLUS  @PlusArithExpr 
                   / MINUS @MinusArithExpr 
                   ) ArithExpr 
            )*
;

generic ArithTerm = 
  ArithFactor ( void:( TIMES @TimesArithTerm
                     / DIV   @DivArithTerm 
                     ) ArithTerm 
              )*
/	
;

generic ArithFactor = 
  ( PLUS / MINUS )? ArithPrimary
;

generic ArithPrimary =
  StateFieldPathExpr 
/ NumericLiteral 
/ LParen ArithExpr RParen
/ InputParam
/ FuncsReturningNumerics
/ AggregateExpr
/ CaseExpr
/ FuncInvocation
/ LParen Subquery RParen
;

generic StringExpr =
  StateFieldPathExpr 
/ StringLiteral 
/ InputParam
/ FuncsReturningStrings
/ AggregateExpr
/ CaseExpr
/ FuncInvocation
/ LParen Subquery RParen
;

generic DatetimeExpr =
  StateFieldPathExpr 
/ InputParam
/ FuncsReturningDatetime
/ AggregateExpr
/ CaseExpr
/ FuncInvocation
/ DatetimeTimestampLiteral
/ LParen Subquery RParen
;

generic BooleanExpr =
  StateFieldPathExpr 
/ BooleanLiteral
/ InputParam
/ CaseExpr
/ FuncInvocation
/ LParen Subquery RParen
;

generic EnumExpr =
  StateFieldPathExpr
/ EnumLiteral
/ InputParam
/ CaseExpr
/ LParen Subquery RParen
;

generic EntityExpr = 
  SingleValuedObjectPathExpr
/ SimpleEntityExpr 
;

generic SimpleEntityExpr = 
  IdentVar
/ InputParam
;

generic EntityTypeExpr =
  TypeDiscriminator
/ InputParam
/ EntityTypeLiteral
;

generic TypeDiscriminator = 
  TYPE LParen ( IdentVar 
              / SingleValuedObjectPathExpr
              / InputParam
              )
       RParen
;

generic FuncsReturningNumerics =
  LENGTH LParen StringExpr RParen
/ LOCATE LParen StringExpr COMMA StringExpr ( COMMA ArithExpr )? RParen
/ ABS    LParen ArithExpr RParen 
/ SQRT   LParen ArithExpr RParen
/ MOD    LParen ArithExpr COMMA ArithExpr RParen 
/ SIZE   LParen CollectionValuedPathExpr RParen
/ INDEX  LParen IdentVar RParen
;

generic FuncsReturningDatetime = 
  CURRENT_DATE
/ CURRENT_TIME
/ CURRENT_TIMESTAMP
;

generic FuncsReturningStrings = 
  CONCAT    LParen StringExpr COMMA StringExpr ( COMMA StringExpr )* RParen 
/ SUBSTRING LParen StringExpr COMMA ArithExpr  ( COMMA ArithExpr  )? RParen
/ TRIM      LParen TrimSpec?  TrimChar? FROM StringExpr RParen 
/ TRIM      LParen StringExpr RParen 
/ LOWER     LParen StringExpr RParen 
/ UPPER     LParen StringExpr RParen
;

generic TrimSpec = 
  LEADING / TRAILING / BOTH
;

generic FuncInvocation =
  FUNCTION LParen StringLiteral ( COMMA FuncArg )* RParen
;

generic FuncArg =
  Literal
/ StateFieldPathExpr
/ InputParam
/ ScalarExpr
;

generic CaseExpr =
  GeneralCaseExpr
/ SimpleCaseExpr
/ CoalesceExpr
/ NullifExpr
;

generic GeneralCaseExpr =
  CASE WhenClause WhenClause* ELSE ScalarExpr END
;

generic WhenClause =
  WHEN CondExpr THEN ScalarExpr
;

generic SimpleCaseExpr =
  CASE CaseOperand SimpleWhenClause SimpleWhenClause* ELSE ScalarExpr END
;

generic CaseOperand =
  StateFieldPathExpr
/ TypeDiscriminator
;

generic SimpleWhenClause =
  WHEN ScalarExpr THEN ScalarExpr
;

generic CoalesceExpr =
  COALESCE LParen ScalarExpr ( COMMA ScalarExpr )+ RParen
;

generic NullifExpr =
  NULLIF LParen ScalarExpr COMMA ScalarExpr RParen
;

generic Literal =
  BooleanLiteral
/ EnumLiteral
/ NumericLiteral
/ StringLiteral
/ DateLiteral 
/ TimeLiteral 
/ TimestampLiteral 
;

generic DatetimeTimestampLiteral =
  DateLiteral
/ TimeLiteral
/ TimestampLiteral
;

generic EnumLiteral =
  ( identifier void:'.' )+ identifier
;

generic EntityTypeLiteral =
  Identifier
;

generic InputParam =
  ':' identifier    @NamedInputParam
/ '?' [1-9] [0-9]*  @PositionInputParam
;

generic CollectionValuedInputParam =
  InputParam
;

generic PatternValue =
  InputParam
/ StringLiteral
;

generic EscapeChar =
  SingleQuotedStringLiteral
;

generic TrimChar =
  SingleQuotedStringLiteral
;

// ----- undefined terms in BNF

generic IdentVar =
  Identifier
;

generic ResultVar =
  Identifier
;

generic EntityName =
  Identifier
;

generic SingleValuedObjectField = 
  PathComponent
;

generic CollectionValuedField = 
  PathComponent
;

generic StateField = 
  ( PathComponent DOT )* PathComponent
;

generic SingleValuedEmbeddableObjectField =
  PathComponent
;

generic ConstructorName =
  Identifier ( DOT PathComponent )*
;

generic Subtype =
  Identifier
;

generic SuperqueryIdentVar =
  Identifier
;

generic SingleValuedInputParam =
  Identifier
;